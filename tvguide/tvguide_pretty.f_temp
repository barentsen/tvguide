!*==TVGUIDE.spg  processed by SPAG 6.72Dc at 17:53 on  4 Jun 2017
!+TVGIODE
      PROGRAM TVGUIDE
 
      IMPLICIT NONE
!*--TVGUIDE6
 
!       Provisional name for a provisional program that provides
!       information about TESS visibility of potential targets
 
!-TVGUIDE
 
      INTEGER N_OPT
      DOUBLE PRECISION DEG2RAD , RAD2DEG
      CHARACTER*12 V_STRING
!       Up to 32 missions allowed
      PARAMETER (N_OPT=4)
!       Degree to radian conversion
      PARAMETER (DEG2RAD=0.01745329252D+00)
      PARAMETER (RAD2DEG=57.29577951D+00)
!       Version number string
      PARAMETER (V_STRING='Version 0.2')
 
      CHARACTER*255 cline
      CHARACTER*10 ra_string
      CHARACTER*9 dec_string
      CHARACTER*80 in_buffer
      CHARACTER*64 star
      CHARACTER*96 out_msg
      LOGICAL do_prec , termin , termout
      INTEGER ir_lo , ir_hi
      INTEGER flag , status , count , i , j , k
      INTEGER lun , in_unit , out_unit
      INTEGER n_obj , len
      INTEGER totint , intvls(13)
      REAL lo_rang , hi_rang , avoid_moon , temp , equinox
      REAL dstart
      DOUBLE PRECISION lambda1 , dlambda , step
      DOUBLE PRECISION edge , corner , gapx , gapy
      DOUBLE PRECISION in_ra , in_dec , alpha , delta , dequinox , jd
      DOUBLE PRECISION lambda , beta , lambda_ , beta0 , lambda0
      DOUBLE PRECISION betas(4)
      DOUBLE PRECISION c1limit , c1gap , c2limit
      DOUBLE PRECISION cc(3) , targt(3) , locx(3) , locy(3)
      DOUBLE PRECISION tgt_cc(3) , offset , offsetx , offsety , cosoff
      DOUBLE PRECISION locxang , locyang
 
      DOUBLE PRECISION VEC_ANGLE
      INTEGER JULIAN , LENTRIM
      CHARACTER*3 mn_name
 
      CHARACTER*16 names(N_OPT)
      INTEGER types(N_OPT)
      CHARACTER*64 prompts(N_OPT)
      CHARACTER*64 values(N_OPT)
      CHARACTER*64 blank
 
      DATA names/'dlambda' , 'equinox' , 'input' , 'output'/
      DATA types/1 , 1 , 1 , 1/
      DATA prompts/' ' , ' ' , ' ' , ' '/
      DATA blank/' '/
 
      INCLUDE 'tvguide.inc'
 
!       Get the command line argument
      CALL ARKGCL(cline)
 
!       Did it just say "help"?
      IF ( cline.EQ.'help' .OR. cline.EQ.'-help' .OR.                   &
         & cline.EQ.'HELP' .OR. cline.EQ.'-HELP' .OR. cline.EQ.'?' )    &
         & THEN
         CALL PWRITE('USAGE: TVGide [dlambda=xx.xx] [equinox=year]'//   &
                    &' [input=<file>] [output=<file>]')
         CALL PWRITE(' ')
         GOTO 900
      ENDIF
 
!       If not, sort out what was specified
      CALL DCD_ARG(cline,names,types,prompts,N_OPT,values,status)
 
      IF ( status.LT.0 ) THEN
         CALL PWRITE('Error decoding the command line arguments')
         GOTO 900
      ENDIF
 
!       Now start processing them --- arg 1 is the dlambda
      IF ( values(1).EQ.' ' ) THEN
         dstart = 0.0
      ELSE
         CALL RD_REAL(values(1),dstart,flag)
         IF ( flag.LT.0 ) THEN
            CALL PWRITE('Error reading dlambda')
            GOTO 900
         ENDIF
      ENDIF
      lambda1 = lambda1 + DBLE(dstart)
 
!       Arg 2 should be the equinox of the coordinates
      IF ( values(2).EQ.' ' ) THEN
!         Use default
         dequinox = 2.00D+03
         do_prec = .FALSE.
      ELSE
         CALL RD_REAL(values(2),equinox,flag)
         IF ( flag.LT.0 ) THEN
            CALL PWRITE('Error reading equinox')
            GOTO 900
         ENDIF
         dequinox = DBLE(equinox)
         IF ( ABS(dequinox-2.00D+03).GT.5.0D-01 ) THEN
            do_prec = .TRUE.
         ELSE
            do_prec = .FALSE.
         ENDIF
      ENDIF
 
!       Arg 3 is the input file (a list of targets)
      IF ( values(3).EQ.' ' ) THEN
         termin = .TRUE.
      ELSE
         termin = .FALSE.
         CALL ARKOPN(in_unit,' ',values(3),'lst','OLD','READONLY',      &
                    &'FORMATTED','SEQUENTIAL',1,flag)
         IF ( flag.NE.0 ) THEN
            CALL PWRITE('Error: failed to open input file')
            GOTO 900
         ENDIF
      ENDIF
 
!       Arg 4 is the output file name
      IF ( values(4).EQ.' ' ) THEN
         termout = .TRUE.
         out_unit = 6
      ELSE
         termout = .FALSE.
         CALL ARKOPN(out_unit,' ',values(4),'lst','NEW','OVERWRITE',    &
                    &'FORMATTED','SEQUENTIAL',1,flag)
         IF ( flag.NE.0 ) THEN
            CALL PWRITE('Error: failed to open output file')
            GOTO 900
         ENDIF
      ENDIF
 
!       Now produce some preliminary output
      IF ( termout ) THEN
         WRITE (out_unit,300) V_STRING
 300     FORMAT (' *** TESS Viewing Guide ',a,'for Cycle 1 ***')
         IF ( .NOT.termin ) THEN
            len = LENTRIM(values(3))
            WRITE (out_unit,304) values(3)(:len)
 304        FORMAT ('     list of targets taken from ',a)
         ENDIF
         WRITE (out_unit,305) dequinox
 305     FORMAT ('     input positions are taken to be for equinox ',   &
               & f6.1)
         WRITE (out_unit,306) lambda1
 306     FORMAT (                                                       &
       &'     output assumes sector 1 centers on ecliptic longitude of '&
      & ,f7.2)
         IF ( dstart.EQ.0.0 ) THEN
            WRITE (out_unit,307)
 307        FORMAT ('     (Use dlambda option to modify)')
         ENDIF
      ENDIF
 
      jd = DBLE(JULIAN(2000,1,1)) - 0.5D+00
      locx(1) = 0.0D+00
      locx(2) = 1.0D+00
      locx(3) = 0.0D+00
      locy(2) = 0.0D+00
 
      n_obj = 0
      DO WHILE ( .TRUE. )
!         Loop over stars
         IF ( termin ) THEN
            star = 'Coordinates input from terminal'
            CALL WRITEN(                                                &
                   &'Enter RA (hh mm [ss.s] or dd.ddd) [<CR> to end] > '&
                  & )
            READ (*,'(a)',END=800) in_buffer
            IF ( in_buffer.EQ.' ' ) GOTO 800
            CALL RD_ASTRO(in_buffer,'R',in_ra,flag)
            IF ( flag.NE.0 ) THEN
               CALL PWRITE('Error in RA --- try again')
               GOTO 700
            ENDIF
            CALL WT_ASTRO(in_ra,+7,ra_string,flag)
            CALL WRITEN('Enter Dec ([s]dd mm [ss.s] or [s]dd.ddd) > ')
            READ '(a)' , in_buffer
            CALL RD_ASTRO(in_buffer,'D',in_dec,flag)
            IF ( flag.NE.0 ) THEN
               CALL PWRITE('Error in Dec --- try again')
               GOTO 700
            ENDIF
            CALL WT_ASTRO(in_dec,-6,dec_string,flag)
            n_obj = n_obj + 1
            WRITE (out_unit,                                            &
                  &'('' * Object #'',I5,'' at ('',A,'', '',A,''):'')')  &
                 & n_obj , ra_string , dec_string
         ELSE
            READ (in_unit,'(a)',END=800) star
            READ (in_unit,'(a)',END=800) in_buffer
            CALL RD_ASTRO(in_buffer,'R',in_ra,flag)
            IF ( flag.NE.0 ) THEN
               CALL PWRITE('Error in RA --- aborting')
               GOTO 800
            ENDIF
            CALL WT_ASTRO(in_ra,+7,ra_string,flag)
            READ (in_unit,'(a)',END=800) in_buffer
            CALL RD_ASTRO(in_buffer,'D',in_dec,flag)
            IF ( flag.NE.0 ) THEN
               CALL PWRITE('Error in Dec --- aborting')
               GOTO 800
            ENDIF
            CALL WT_ASTRO(in_dec,-6,dec_string,flag)
            len = LENTRIM(star)
         ENDIF
 
         IF ( do_prec ) THEN
!           Display coordinates precessed to J2000 for convenience
            CALL ARK_PREC(in_ra,in_dec,dequinox,jd,alpha,delta)
            CALL WT_ASTRO(alpha,+7,ra_string,flag)
            CALL WT_ASTRO(delta,-6,dec_string,flag)
            IF ( termout ) WRITE (out_unit,                             &
                      &'(''   [J2000 coordinates: ('',a,'','',a,'')]'')'&
                     & ) ra_string , dec_string
         ELSE
            alpha = in_ra
            delta = in_dec
         ENDIF
 
         totint = 0
         DO j = 1 , 13
            intvls(j) = 0
         ENDDO
!         Find the ecliptic latitude, draw some conclusions from that
         CALL TO_ECLIP(alpha,delta,jd,lambda,beta)
         IF ( termout ) THEN
            WRITE (out_unit,310) lambda , beta
 310        FORMAT ('Ecliptic longitude: ',f7.2,'; latitude: ',f7.2)
         ENDIF
         IF ( beta.LE.c1limit ) THEN
!           In the southern ecliptic hemisphere - potential Cycle 1 target
            IF ( beta.GE.c1gap ) THEN
               IF ( termout ) WRITE (out_unit,                          &
              &'(''This target might fall in the gap between sectors'')'&
             & )
            ELSE
               IF ( termout ) WRITE (out_unit,                          &
                &'(''This target should be observable during Cycle 1'')'&
               & )
            ENDIF
!           Try with 13 sectors starting with ecliptic longitude L0+delta
            DO j = 1 , 13
               lambda0 = lambda1 + (j-1)*step
               lambda_ = lambda - lambda0
               CALL ECL_CARTS(lambda_,beta,targt)
               DO k = 1 , 4
                  CALL ECL_CARTS(0.0D+00,betas(k),cc)
                  offset = VEC_ANGLE(targt,cc)
                  cosoff = COS(offset*DEG2RAD)
                  IF ( offset.LE.corner ) THEN
                     DO i = 1 , 3
                        tgt_cc(i) = targt(i)/cosoff - cc(i)
                     ENDDO
!         Get the angle between cc and targt
!         but what I really care is the angle between tgt_cc
!         projected along locx/locy an
                     CALL VEC_RENRM(tgt_cc)
                     beta0 = betas(k)*DEG2RAD
                     locy(1) = -SIN(beta0)
                     locy(3) = COS(beta0)
                     locxang = VEC_ANGLE(tgt_cc,locx)*DEG2RAD
                     locyang = VEC_ANGLE(tgt_cc,locy)
                     offsetx = offset*COS(locxang)
                     IF ( locyang.LE.90.0 ) THEN
                        offsety = offset*SIN(locxang)
                     ELSE
                        offsety = -offset*SIN(locxang)
                     ENDIF
                     IF ( ABS(offsetx).LE.edge .AND. ABS(offsety)       &
                        & .LE.edge ) THEN
                        IF ( termout ) THEN
                           WRITE (out_unit,400) j , k , offsetx ,       &
                                & offsety
 400                       FORMAT ('Observable in sector ',i2,          &
                                 & ' camera ',i2,' at offsets of (',    &
                                 & f6.2,',',f6.2,')')
                        ENDIF
                        IF ( ABS(offsetx).LE.gapx .OR. ABS(offsety)     &
                           & .LE.gapy ) THEN
                           IF ( termout ) THEN
                              WRITE (out_unit,401)
 401                          FORMAT ('Except it may be in the chip gap'&
                                    & )
                           ENDIF
                        ELSE
                           intvls(j) = k
                           totint = totint + 1
                        ENDIF
                     ENDIF
                  ENDIF
               ENDDO
            ENDDO
 
         ELSEIF ( beta.GT.c2limit ) THEN
            IF ( termout ) WRITE (out_unit,                             &
                     &'(''This target may be observed during Cycle 2'')'&
                    & )
         ELSE
            IF ( termout ) WRITE (out_unit,                             &
             &'(''This target cannot be observed during Cycle 1 or 2'')'&
            & )
         ENDIF
 
         IF ( .NOT.termout ) THEN
            WRITE (out_unit,600) totint , star(:len) , intvls
 600        FORMAT (i2,' ',a,13(' ',i1))
         ENDIF
!         Rejoin here if error found during interactive input
 700     CONTINUE
      ENDDO
 
!       Rejoin here at <CR>/EOF
!       <EOF> or equivalent detected
 800  CONTINUE
      IF ( .NOT.termin ) CLOSE (in_unit)
      IF ( out_unit.NE.6 ) CLOSE (out_unit)
 
 900  CONTINUE
 
      END
